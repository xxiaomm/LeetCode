
### Link

https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/

### Clarifications / Constraints

1. unique value ?

### Idea_1

1. DFS, Recursion


#### Code

```java
// DFS, Recursion, O(n), O(H)
class Solution {
    int pos = 0;
    public TreeNode bstFromPreorder(int[] pre) {
        return build(pre, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }
    public TreeNode build(int[] pre, int low, int high) {
        if (pos >= pre.length) return null;
        if (pre[pos] <= low || pre[pos] >= high) 
            return null;
        TreeNode root = new TreeNode(pre[pos++]);
        root.left = build(pre, low, root.val);
        root.right = build(pre, root.val, high);
        return root;
    }
}
```

#### Complexity

Time complexity: O(n);    
Space complexity: O(H); 


### Idea_2

1. Iteration, stack 


#### Code

```java
// Iteration, stack 
class Solution {
    public TreeNode bstFromPreorder(int[] pre) {
        if (pre.length <= 0) return null;
        int pos = 0;
        Deque<TreeNode> s = new LinkedList<>();
        TreeNode root = new TreeNode(pre[pos++]);
        s.push(root);
        while (pos < pre.length) {
            TreeNode child = new TreeNode(pre[pos++]);
            TreeNode node = s.peek();
            while (!s.isEmpty() && s.peek().val < child.val)
                node = s.pop();
            
            if (node.val > child.val) node.left = child;
            if (node.val < child.val) node.right = child;
            s.push(child);
        }
        return root;
    }
}
```

#### Complexity

Time complexity: O(n);     
Space complexity: O(n);
