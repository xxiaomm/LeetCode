
### Link

https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

### Clarifications / Constraints

1. postorder and inorder consist of ***unique*** values.

### Idea_1

1. 


#### Code

```java
// inorder = [9,3,15,20,7], 
// postorder = [9,15,7,20,3]
// Output: [3,9,20,null,null,15,7]
class Solution {
    Map<Integer, Integer> m = new HashMap<>();
    public TreeNode buildTree(int[] in, int[] post) {
        for (int i = 0; i < in.length; i++) 
            m.put(in[i], i);
        
        return build(in, 0, in.length - 1, post, 0, post.length - 1);
    }
    public TreeNode build(int[] in, int inL, int inR, int[] post, int postL, int postR) {
        if (inL > inR) return null;
        TreeNode root = new TreeNode(post[postR]);
        int pos = m.get(root.val);
        
        root.left = build(in, inL, pos - 1, post, postL, postL + pos - inL - 1);
        root.right = build(in, pos + 1, inR, post, postL + pos - inL, postR - 1);
        return root;
    }
}
```

#### Complexity

Time complexity: O(n);  
Space complexity: O(n);


### Idea_2

1. 


#### Code

```java
// DFS: O(n), O(n)
class Solution {
    int in = 0, post = 0;
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        in = inorder.length-1;
        post = postorder.length-1;
        return helper(inorder, postorder, Integer.MIN_VALUE);
    }
    public TreeNode helper(int[] inorder, int[] postorder, int stop) {
        if (post < 0) return null;
        if (inorder[in] == stop) {
            in--;
            return null;
        }
        TreeNode root = new TreeNode(postorder[post--]);
        root.right = helper(inorder, postorder, root.val);
        root.left = helper(inorder, postorder, root.val);
        return root;
    }
}
```

#### Complexity

Time complexity:  
Space complexity: 
