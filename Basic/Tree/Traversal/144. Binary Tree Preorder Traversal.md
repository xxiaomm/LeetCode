
### Link

https://leetcode.com/problems/binary-tree-preorder-traversal/

### Clarifications / Constraints

1. the number of nodes >= 0

### Idea_1

1. DFS;
2. We adopt the depth as the priority, so that one would start from a root and reach all the way down to certain leaf, and then back to root to reach another branch;
3. So, firstly, wee add the current value into the result, then traverse its left subtree and then right subtree;

#### Code

```java
// DFS
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        dfs(root, res);
        return res;
    }
    public void dfs(TreeNode root, List<Integer> res) {
        if (root == null) return;
        res.add(root.val);
        dfs(root.left, res);
        dfs(root.right, res);
    }
}
```

#### Complexity

Time complexity: O(n);   
Space complexity: O(height), best: O(logn), worst: O(n);  


### Idea_2

1. BFS;
2. Use stack to store the nodes; 
3. Start from the root, then at each iteration, pop the current node out of the stack and push its child nodes, push right first and then left;
4. In the implemented strategy we push nodes into output list following the order Top->Bottom and Left->Right, that naturally reproduces preorder traversal.

#### Code

```java
// BFS
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> s = new LinkedList<>();
        if (root != null) s.push(root);
        while (!s.isEmpty()) {
            TreeNode curr = s.pop();
            res.add(curr.val);
            if (curr.right != null) 
                s.push(curr.right);
            if (curr.left != null)
                s.push(curr.left);
        }
        return res;
    }
}
```

#### Complexity

Time complexity: O(n);  
Space complexity: O(height), the maximum height of stack is the height of the tree;


### Idea_3

1. Morris   

Algorithm
Here the idea is to go down from the node to its predecessor, and each predecessor will be visited twice. For this go one step left if possible and then always right till the end. When we visit a leaf (node's predecessor) first time, it has a zero right child, so we update output and establish the pseudo link predecessor.right = root to mark the fact the predecessor is visited. When we visit the same predecessor the second time, it already points to the current node, thus we remove pseudo link and move right to the next node.

If the first one step left is impossible, update output and move right to next node.

#### Code

```java

```

#### Complexity

Time complexity: O(n);  
Space complexity: O(1);
