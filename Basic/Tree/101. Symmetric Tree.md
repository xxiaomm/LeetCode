
### Link

https://leetcode.com/problems/symmetric-tree/

### Clarifications / Constraints

1. 

### Idea_1

1. BFS


#### Code

```java
// BFS: O(n), O(D)
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null)   return true;
        // 每相邻的俩个node应该保持一致
        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode p = queue.poll();
            TreeNode q = queue.poll();
            if (q == null && p == null) continue;
            if (q == null || p == null || p.val != q.val)
                return false;
            queue.offer(p.left);
            queue.offer(q.right);
            queue.offer(p.right);
            queue.offer(q.left);
        }
        return true;
    }
}
```

#### Complexity

Time complexity: O(n);   
Space complexity: O(D); 


### Idea_2

1. DFS


#### Code

```java
// DFS: O(n), O(H)
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null)   return true;
        
        return isMirror(root.left, root.right);
    }
    public boolean isMirror(TreeNode m, TreeNode n) {
        if (m == null && n == null) return true;
        if (m == null || n == null || m.val != n.val)
            return false;
        return isMirror(m.left, n.right) && isMirror(m.right, n.left);
    }
}
```

#### Complexity

Time complexity: O(n);    
Space complexity: O(H);
