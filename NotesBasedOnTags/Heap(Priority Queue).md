
如果永远都维护一个有序数组的方式取极值很容易，但是插队麻烦。

如果永远都维护一个有序链表的方式取极值也容易。 不过要想查找足够快，而不是线性扫描，就需要借助索引，这种实现对应的就是优先级队列的跳表实现。

如果永远都维护一个树的方式取极值也可以实现，比如根节点就是极值，这样 O(1) 也可以取到极值，但是调整过程需要 $O(logN)$。这种实现对应的就是优先级队列的二叉堆实现。

简单总结下就是，堆就是动态帮你求极值的。当你需要动态求最大或最小值就就用它。而具体怎么实现，复杂度的分析我们之后讲，现在你只要记住使用场景，堆是如何解决这些问题的以及堆的 api 就够了。





## Reference

[lucifer堆（上）](https://lucifer.ren/blog/2020/12/26/heap/)   
[lucifer堆（下）](https://lucifer.ren/blog/2021/01/19/heap-2/)