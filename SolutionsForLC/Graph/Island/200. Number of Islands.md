
### Link

https://leetcode.com/problems/number-of-islands/

### Clarifications / Constraints

1. 

### Idea_1

1. DFS


#### Code

```java
// DFS: O(mn), O(mn)
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    count++;
                }
            }
        }
        return count;
    }
    public void dfs(char[][] grid, int x, int y) {
        if (x < 0 || x >= grid.length || y < 0 
            || y >= grid[0].length || grid[x][y] == '0')
            return;
        grid[x][y] = '0'; // mark visited island
        dfs(grid, x + 1, y);
        dfs(grid, x, y + 1);
        dfs(grid, x - 1, y);
        dfs(grid, x, y - 1);
    }
}
```

#### Complexity

Time complexity: O(M×N) where M is the number of rows and N is the number of columns.

Space complexity: worst case O(M×N) in case that the grid map is filled with lands where DFS goes by M×N deep.  


### Idea_2

1. BFS！！！


#### Code

```java
class Solution {
  public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0) {
      return 0;
    }

    int nr = grid.length;
    int nc = grid[0].length;
    int num_islands = 0;

    for (int r = 0; r < nr; ++r) {
      for (int c = 0; c < nc; ++c) {
        if (grid[r][c] == '1') {
          ++num_islands;
          grid[r][c] = '0'; // mark as visited
          Queue<Integer> neighbors = new LinkedList<>();
          neighbors.add(r * nc + c);
          while (!neighbors.isEmpty()) {
            int id = neighbors.remove();
            int row = id / nc;
            int col = id % nc;
            if (row - 1 >= 0 && grid[row-1][col] == '1') {
              neighbors.add((row-1) * nc + col);
              grid[row-1][col] = '0';
            }
            if (row + 1 < nr && grid[row+1][col] == '1') {
              neighbors.add((row+1) * nc + col);
              grid[row+1][col] = '0';
            }
            if (col - 1 >= 0 && grid[row][col-1] == '1') {
              neighbors.add(row * nc + col-1);
              grid[row][col-1] = '0';
            }
            if (col + 1 < nc && grid[row][col+1] == '1') {
              neighbors.add(row * nc + col+1);
              grid[row][col+1] = '0';
            }
          }
        }
      }
    }

    return num_islands;
  }
}
```

#### Complexity

Time complexity: O(M×N) where M is the number of rows and N is the number of columns.

Space complexity: O(min(M,N)) because in worst case where the grid is filled with lands, the size of queue can grow up to min(MM,N).
