
### Link

https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

### Clarifications / Constraints

1. preorder and inorder consist of ***unique*** values.

### Idea_1

1. 


#### Code

```java
// preorder = [3,9,20,15,7], 
// inorder =  [9,3,15,20,7]
// Output: [3,9,20,null,null,15,7]
class Solution {
    Map<Integer, Integer> m = new HashMap<>();
    public TreeNode buildTree(int[] pre, int[] in) {
        // store the index of each ele in inorder
        for (int i = 0; i < in.length; i++)
            m.put(in[i], i);
        
        return build(pre, 0, pre.length-1, in, 0, in.length-1);
    }
    public TreeNode build(int[] pre, int preL, int preR, int[] in, int inL, int inR) {
        if (preL > preR) return null;
        TreeNode root = new TreeNode(pre[preL]);
        int index = m.get(pre[preL]);   // so that use constant time
        root.left = build(pre, preL+1, preL + index - inL, in, inL, index - 1);
        root.right = build(pre, preL + index - inL + 1, preR, in, index + 1, inR);
        
        return root;
    }
}
```

#### Complexity

Time complexity: O(n);    
Both building the hashmap and building the tree take O(N) time => O(n);  

Space complexity: O(n);    
Building the hashmap and storing the entire tree each requires O(N) memory. Stack used by recursion calls depends on the height of the tree O(H), which is O(N) in the worst case and O(logN) on average. Taking both into consideration, the space complexity is O(N).



### Idea_2

1. 


#### Code

```java
// https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34543/Simple-O(n)-without-map
// O(n), O(n)
class Solution {
    int in = 0;
    int pre = 0;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, inorder, Integer.MIN_VALUE);
    }   
    private TreeNode build(int[] preorder, int[] inorder, int stop) {
        if (pre >= preorder.length) return null;
        if (inorder[in] == stop) {
            in++;
            return null;
        }
        TreeNode node = new TreeNode(preorder[pre++]);
        node.left = build(preorder, inorder, node.val);
        node.right = build(preorder, inorder, stop);
        return node;        
    }
}
```

#### Complexity

Time complexity:  
Space complexity: 
