
### Link



### Clarifications / Constraints

1. unique value

### Idea_1

1. DFS


#### Code

```java
// preorder = [1,2,4,5,3,6,7], 
// postorder = [4,5,2,6,7,3,1]
// Output: [1,2,3,4,5,6,7]
class Solution {
    Map<Integer, Integer> m = new HashMap<>();
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        for (int i = 0; i < post.length; i++)
            m.put(post[i], i);
        
        return build(pre, 0, pre.length-1, post, 0, post.length-1);
    }
    public TreeNode build(int[] pre, int preL, int preR, int[] post, int postL, int postR) {
        if (preL > preR) return null;
        TreeNode root = new TreeNode(pre[preL]);
        if (preL + 1 <= preR) {
            int pos = m.get(pre[preL+1]);
            root.left = build(pre, preL + 1, preL + pos + 1 - postL, post, postL, pos);
            root.right = build(pre,  preL + pos + 2 - postL, preR, post, pos + 1, postR - 1);
        }
        return root;
    }
}
```

#### Complexity

Time complexity: O(n);   
Space complexity O(n); 


### Idea_2

1. 


#### Code

```java

```

#### Complexity

Time complexity:  
Space complexity: 
