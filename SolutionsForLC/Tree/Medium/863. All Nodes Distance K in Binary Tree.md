
### Link

https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/

### Clarifications / Constraints

1. all values are unique?
2. no target ?
3. the number of nodes
4. k >= 0 ?

### Idea_1

1. BFS


#### Code

```java
// BFS: consider the target as root, use BFS, add its child nodes and parent node into the queue, then find the k distance nodes;
class Solution {
    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        // we need find parent, so use hash map;
        Map<TreeNode, TreeNode> parent = new HashMap<>();
        dfs(root, parent);
        // prevent to visit the node again, use a set
        Set<TreeNode> visited = new HashSet<>();
        List<Integer> res = new LinkedList<>();
        Deque<TreeNode> q = new LinkedList<>();
        q.offer(target);
        
        while (!q.isEmpty()) {
            if (k == -1) return res;    // all distance = k has been added
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                root = q.poll();
                visited.add(root);      // has visited
                if(k == 0) res.add(root.val); 
                // has left node and it hasn't been visited
                if (root.left != null && !visited.contains(root.left))
                    q.offer(root.left);
                // has right node and it hasn't been visited
                if (root.right != null && !visited.contains(root.right))
                    q.offer(root.right);
                // has parent node and it hasn't been visited
                if (parent.containsKey(root) && !visited.contains(parent.get(root)))
                    q.offer(parent.get(root));
            }
            k--;
        }
        return res;
    }
    // traverse to store parent of every node
    public void dfs(TreeNode root, Map<TreeNode, TreeNode> parent) {
        if (root == null) return;
        if (root.left != null)
            parent.put(root.left, root);
        if (root.right != null)
            parent.put(root.right, root);
        dfs(root.left, parent);
        dfs(root.right, parent);
    }
}
```

#### Complexity

Time complexity: O(n), traverse all nodes;  
Space complexity: O(n), hash map; 


### Idea_2

1. DFS 


#### Code

```java
// DFS: start from target node, use dfs to traverse every path, including child nodes and parent node; so we need a hashmap to store parent connection and a set to store visited nodes; when the path becomes deeper, k-1, when k == 0, add current node to the result;
class Solution {
    // we need find parent, so use hash map;
    Map<TreeNode, TreeNode> parent = new HashMap<>();
    // prevent to visit the node again, use a set
    Set<TreeNode> visited = new HashSet<>();
    List<Integer> res = new LinkedList<>();
    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        getParent(root);
        dfs(target, k);
        return res;
    }
    public void dfs(TreeNode root, int k) {
        if (root == null || k < 0 || visited.contains(root)) return;
        if (k == 0) res.add(root.val);
        visited.add(root);
        dfs(root.left, k - 1);
        dfs(root.right, k - 1);
        dfs(parent.get(root), k - 1);
    }
    
    // traverse to store parent of every node
    public void getParent(TreeNode root) {
        if (root == null) return;
        if (root.left != null)
            parent.put(root.left, root);
        if (root.right != null)
            parent.put(root.right, root);
        getParent(root.left);
        getParent(root.right);
    }
}
```

#### Complexity

Time complexity: O(n);  
Space complexity: O(n);
