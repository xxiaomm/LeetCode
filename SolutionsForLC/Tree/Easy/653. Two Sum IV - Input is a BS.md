
### Link

https://leetcode.com/problems/two-sum-iv-input-is-a-bst/

### Clarifications / Constraints

1. 

### Idea_1

1. Recursion, DFS


#### Code

```java
class Solution {
    Set<Integer> set = new HashSet<>();
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) return false;
        if (set.contains(k-root.val))
            return true;
        set.add(root.val);
        return findTarget(root.left, k) || findTarget(root.right, k);
    }
}
class Solution {
    Set<Integer> set = new HashSet<>();
    boolean res = false;
    public boolean findTarget(TreeNode root, int k) {
        dfs(root, k);
        return res;
    }
    public void dfs(TreeNode root, int k) {
        if (root == null || res) return;
        if (set.contains(k - root.val))
            res = true;
        set.add(root.val);
        dfs(root.left, k);
        dfs(root.right, k);
    }
}

```

#### Complexity

Time complexity: O(n)  
Space complexity: O(n)


### Idea_2

1. inorder traverse + binary search


#### Code

```java
// O(n), O(n)
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) return false;
        List<Integer> arr = new ArrayList<>();
        inorder(root, arr);
        int i = 0, j = arr.size()-1; // 是size() 不是length
        while (i < j) {
            if (arr.get(i) + arr.get(j) == k) return true;
            else if (arr.get(i) + arr.get(j) > k) j--;
            else i++;
        }
        return false;
    }
    public void inorder(TreeNode root, List<Integer> arr) {
        if (root == null) return;
        inorder(root.left, arr);
        arr.add(root.val);
        inorder(root.right, arr);
    }
```

#### Complexity

Time complexity: O(n),  
Space complexity: O(n)
