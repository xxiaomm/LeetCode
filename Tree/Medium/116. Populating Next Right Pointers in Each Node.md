
### Link

https://leetcode.com/problems/populating-next-right-pointers-in-each-node/

### Clarifications / Constraints

1. root == null -> return null

### Idea_1

1. Use level taversal;
2. Use queue to store the nodes of every level;
3. For every level, implement ```for``` loop to traverse every node;
   1. if the current is not the last, its next pointer should point to the next node;
   2. else: point to ```null```;


#### Code

```java
class Solution {
    public Node connect(Node root) {
        if (root == null) return root;
        Queue<Node> q = new ArrayDeque<>();
        q.offer(root);
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                Node n = q.poll();
                if (i == size - 1) n.next = null;
                else n.next = q.peek();
                if (n.left != null) q.offer(n.left);
                if (n.right != null) q.offer(n.right);
            }
        }
        return root;
    }
}
```

#### Complexity

Time complexity: O(n), traverse every node in the tree;    
Space complexity: O(n), the maximum number is the number of leafs: n/2;


### Idea_2

1. Use the next pointer, We establish the next pointers for a level N while we are still on level N-1;
2. To start on a particular level, we need to store the leftmost pointer of next level, implement ```while``` loop if ```leftmost != null```;
3. Use ```while``` loop to traverse the current level:
   1. if it has left: ```curr.left.next = curr.right```;
   2. if it has next: ```curr.right.next = curr.next.left```;
   3. the move ```curr``` to ```curr.next```;
   4. if ```curr.next == null```, move to next level;


#### Code

```java
class Solution {
    public Node connect(Node root) {
        if (root == null) return root;
        Node leftmost = root, curr = root;
        while (leftmost != null) {
            leftmost = curr.left;
            while (curr.left != null) {
                curr.left.next = curr.right;
                if (curr.next != null){
                    curr.right.next = curr.next.left;
                    curr = curr.next;
                } else
                    break;
            }
            curr = leftmost;
        }
        return root;
    }
}
```

#### Complexity

Time complexity: O(n), traverse every node in the tree;    
Space complexity: O(1); 
