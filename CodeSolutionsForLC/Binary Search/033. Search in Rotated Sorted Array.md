


### Link

https://leetcode.com/problems/search-in-rotated-sorted-array/

### Clarifications / Constraints

1. no target = > -1
2. element: unique
3. minimum length: >= 1

### Idea

1. Binary Search
2. mid = l + (r - l) / 2:
   1. nums[mid] == target: return mid
   2. nums[mid] > target:  
      1. condition to move left: 
        when nums[mid] in ascending range but target in the decending range =>  
        if nums[r] < nums[mid] && target <= nums[r]:   l = mid + 1;
      2. else: r = mid - 1; 
   3. nums[mid] < target:
      1. condition t o move right: 
        when nums[mid] in decending range but target in the ascending range =>  
        if nums[l] > nums[mid] && target >= nums[l]: r = mid - 1; 
      2. else: l = mid + 1;


#### Code

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            // System.out.println(nums[mid]+" "+nums[l]+" "+ nums[r]);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] > target) {
                if (nums[r] < nums[mid] && target <= nums[r]) 
                    l = mid + 1;        // 考虑什么时候是不正常的条件
                else
                    r = mid - 1;        // 正常情况下
            } else {
                if (nums[l] > nums[mid] && target >= nums[l])
                    r = mid - 1;
                else 
                    l = mid + 1;        // 正常情况下
            }
        }
        return -1;
    }
}

class Solution {
    // O(logn), O(1)
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] >= nums[left]) {
                if (target >= nums[left] && target < nums[mid] )
                    right = mid - 1;
                else left = mid + 1;
            } else {
                if (target >= nums[left] || target < nums[mid]) 
                    right = mid - 1;
                else left = mid + 1;
            }
        }
        return -1;
    }
}

```

#### Complexity

Time complexity: O(logn);  
Space complexity: O(1) 

