### Link

https://leetcode.com/problems/binary-search/

### Clarifications / Constraints

1. minimum and maximum length of the array => r+l 可能溢出 => mid = l + (r - l) / 2
2. unique? => the result is unique

### Idea

1. 最basic的Binary Search;
2. calculate the mid:
   1. nums[mid] == target: return mid;
   2. nums[mid] > target: right = mid - 1 找左边;
   3. nums[mid] < target: left = mid + 1 找右边;


#### Code

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l <= r)  {
            int mid = l + ( r- l) / 2;
            if (nums[mid] == target) 
                return mid;
            else if (nums[mid] > target) 
                r = mid - 1;
            else 
                l = mid + 1;
        }
        return -1;
    }
}
```

#### Complexity

Time complexity: O(logn);  
Space complexity: O(1);