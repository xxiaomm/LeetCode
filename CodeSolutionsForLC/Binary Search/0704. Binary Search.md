
## Link

https://leetcode.com/problems/binary-search/

## Clarifications / Constraints

1. minimum and maximum length of the array => r+l 可能溢出 => mid = l + (r - l) / 2
2. unique? => the result is unique

## Solution 1

- **Algo:** Binary Search   
- **Steps:**  
  - 最basic的Binary Search;
  - calculate the mid:
   1. nums[mid] == target: return mid;
   2. nums[mid] > target: right = mid - 1 找左边;
   3. nums[mid] < target: left = mid + 1 找右边;


### Code

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l <= r)  {
            int mid = l + ( r- l) / 2;
            if (nums[mid] == target) 
                return mid;
            else if (nums[mid] > target) 
                r = mid - 1;
            else 
                l = mid + 1;
        }
        return -1;
    }
}
```

### Complexity

- **Time complexity:** O(logn)     
   

- **Space complexity:** O(1)  

   


## Solution 2

- **Algo:**    
- **Steps:**
  -  xx


### Code

```java

```

### Complexity

- **Time complexity:**      
   

- **Space complexity:**   
    


## Solution 3

- **Algo:**    
- **Steps:**
  - xx


### Code

```java

```

### Complexity

- **Time complexity:**      
   

- **Space complexity:**   

    