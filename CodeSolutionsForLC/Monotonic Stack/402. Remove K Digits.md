
### Link

https://leetcode.com/problems/remove-k-digits/

### Clarifications / Constraints

1. 

### Idea_1

1. Monotonic stack


#### Code

```java
// 两个相同位数的数字大小关系: 取决于第一个不同的数的大小。
// 等价于, 出现降序时, 把较大的删除, 对比未删除的, 
// 该位置是max那个,而删除的同一位置的数一定更小 -> 单调递增序列
class Solution {
    public String removeKdigits(String num, int k) {
        Stack<Character> stack = new Stack<>();
        int n = num.length();
        for (int i = 0; i < num.length(); i++) {
            char c = num.charAt(i);
            while (k > 0 && !stack.isEmpty() && stack.peek() > c){
                stack.pop();
                k--;
            }
            stack.push(c);
        }
        while (k-- > 0) 
            stack.pop();

        StringBuilder sb = new StringBuilder();
        for (char c : stack) {
            if (sb.length() == 0 && c == '0') 
                continue; // 用例"10200", 1; 用例"10", 2
            sb.append(c);
        }
        return sb.length() == 0 ? "0" : sb.toString();
    }
}
```

#### Complexity

Time complexity : O(N).   
Although there are nested loops, the inner loop is bounded to be run at most k times globally. Together with the outer loop, we have the exact (N + k) number of operations. Since 0 < k ≤ <= N, the time complexity of the main loop is bounded within 2N. For the logic outside the main loop, it is clear to see that their time complexity is O(N). As a result, the overall time complexity of the algorithm is O(N).

Space complexity : O(N). We have a stack which would hold all the input digits in the worst case.