
### Link

https://leetcode.com/problems/maximum-depth-of-binary-tree/

### Clarifications / Constraints

1. root: depth =1
2. root: null -> return 0

### Idea

1. DFS


#### Code

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return dfs(root, 1);
    
    }
    public int dfs(TreeNode root, int depth) {
        if (root == null) return depth-1;
        int left = dfs(root.left, depth+1);
        int right = dfs(root.right, depth+1);
        return Math.max(left, right);
    }
}
// DFS: O(n), O(H)
class Solution {
    int max = Integer.MIN_VALUE;
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        dfs(root, 1);
        return max;
    }
    public void dfs(TreeNode root, int d) {
        if (root == null) return;
        max = Math.max(max, d);
        dfs(root.left, 1+d);
        dfs(root.right, 1+d);
    }
}

```

#### Complexity

Time complexity: O(n), traverse all nodes.  
Space complexity: O(height), recursion stack need height space. the worst is n, the best is logn. 

### Idea

1. BFS


#### Code

```java


```

#### Complexity

Time complexity: O(n);  
Space complexity: O(D), 

