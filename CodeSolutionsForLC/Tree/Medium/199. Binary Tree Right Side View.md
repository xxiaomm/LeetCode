
### Link

https://leetcode.com/problems/binary-tree-right-side-view/

### Clarifications / Constraints

1. the number of nodes >= 0

### Idea_1

1. BFS, level traversal
2. Initiate the list of right side view;
3. Initiate the queue by adding a root, initiate current node as root;
4. While the queue is not empty:   
   1. get the size of current queue, it is the number of nodes at the current level;
   2. traverse the current level, if the node is the last one, add it to the result list;
   3. push left and right nodes into the queue;


#### Code

```java
// BFS: level order
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        if (root == null) return new ArrayList<>();
        List<Integer> res = new ArrayList<>();
        Queue<TreeNode> q = new ArrayDeque<>();
        q.offer(root);
        while (!q.isEmpty()) {
            int sz = q.size();
            for(int i = 0; i < sz; i++) {
                TreeNode n = q.poll();
                if (i == sz - 1) res.add(n.val);
                if (n.left != null) q.offer(n.left);
                if (n.right != null) q.offer(n.right);
            }
        }
        return res;
    }
}
```

#### Complexity

Time complexity: O(n);  
Space complexity: O(d), worst: O(n);


### Idea_2

1. DFS
2. Use ***depth*** to record the current depth;
3. If the length of the result list is equals to the depth, add the current value into the list; or, traverse its right node first and then left node; because for right side view, right subtree occurs first; 


#### Code

```java
// DFS
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        if (root == null) return new ArrayList<>();
        dfs(root, 0);
        return res;
    }
    public void dfs(TreeNode root, int depth) {
        if (root == null) return;
        if (depth == res.size())
            res.add(root.val);
        dfs(root.right, depth + 1);
        dfs(root.left, depth + 1);
    }
}
```

#### Complexity

Time complexity: O(n);  
Space complexity: O(height), worst: O(n);
